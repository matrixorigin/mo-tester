package io.mo.result;

import io.mo.cases.SqlCommand;
import io.mo.constant.RESULT;
import org.apache.log4j.Logger;
import org.apache.xmlbeans.impl.xb.xsdschema.PatternDocument;

import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class StmtResult {
    /**
     * result type, value can be:
     * 0,means result is type of ResultSet
     * 1,means result is type of ErrorMessage
     * 2,means result is NULL
     */
    private int type = RESULT.STMT_RESULT_TYPE_INIT;
    private String errorMessage = null;

    private RSSet rsSet = null;

    private SqlCommand command;

    //restore the orginal result text read from the test result file
    //if instance is generated by the real ResultSet from the jdbc, it does not make any senses
    private String orginalRSText = null;

    private static Logger LOG = Logger.getLogger(StmtResult.class.getName());


    public StmtResult(String errorMessage){
        this.type = RESULT.STMT_RESULT_TYPE_ERROR;
        this.errorMessage = errorMessage;
    }

    public StmtResult(RSSet rsSet){
        this.rsSet = rsSet;
        if(this.command != null) {
            this.rsSet.setCommand(command);
            if (command.getSeparator().equals("both") || command.getSeparator().equals("space"))
                this.rsSet.setSeparator(RESULT.COLUMN_SEPARATOR_SPACE);
            else
                this.rsSet.setSeparator(RESULT.COLUMN_SEPARATOR_TABLE);

            //add sort key indexes
            for(int i = 0; i < command.getSortKeyIndexs().size();i++){
                this.rsSet.addSortKeyIndex(command.getSortKeyIndexs().get(i));
            }
        }
        if(rsSet.getAbnormalError() == null)
            this.type = RESULT.STMT_RESULT_TYPE_SET;
        else
            this.type = RESULT.STMT_RESULT_TYPE_ABNORMAL;
    }

    public StmtResult(){
    }

    /**
     * compare whether this equals the argument stmtResult
     * @param stmtResult
     * @return
     */
    public boolean equals(StmtResult stmtResult){
        if(this.type != stmtResult.getType()){
            return false;
        }else {
            if(this.type == RESULT.STMT_RESULT_TYPE_ERROR){
                if(this.errorMessage == null){
                    if(stmtResult.getErrorMessage() != null){
                        return false;
                    }
                }

                if(stmtResult.getErrorMessage() == null){
                    if(this.errorMessage != null){
                        return false;
                    }
                }
                
                if(!this.errorMessage.trim().equals(stmtResult.getErrorMessage().trim())){
                    return false;
                }
            }

            if(this.type == RESULT.STMT_RESULT_TYPE_SET){
                if(this.rsSet == null){
                    if(stmtResult.getRsSet() != null){
                        return false;
                    }
                }

                if(stmtResult.getRsSet() == null){
                    if(this.rsSet != null){
                        return false;
                    }
                }

                if(this.rsSet.getAbnormalError() != null || stmtResult.getRsSet().getAbnormalError() != null){
                    return false;
                }

                //System.out.println("act : " + stmtResult.getRsSet().toString());
                if(!this.rsSet.equals(stmtResult.getRsSet())){
                    return false;
                }
            }
        }

        return true;
    }
    
    public boolean regularMatch(StmtResult stmtResult){
        if(stmtResult.errorMessage == null || stmtResult.errorMessage.equalsIgnoreCase("")){
            LOG.error("NULL or EMPTY can not regularly match the expected result");
            return false;
        }
        if(stmtResult.errorMessage.matches(this.errorMessage))
            return true;
        else {
            LOG.error(String.format("[%s] can not match : \n %s",stmtResult.errorMessage,this.errorMessage));
            return false;
        }
    }

    /**
     * Check if the actual result contains all the hint keywords
     * This is used for cases like EXPLAIN where we only want to verify certain keywords exist
     * rather than comparing the entire output
     * @param stmtResult the actual result
     * @param hintKeywords the list of keywords that must be present in the result
     * @return true if all keywords are found, false otherwise
     */
    public boolean hintMatch(StmtResult stmtResult, ArrayList<String> hintKeywords){
        if(hintKeywords == null || hintKeywords.isEmpty()){
            LOG.error("Hint keywords list is null or empty, cannot perform hint match");
            return false;
        }
        
        String actualContent = null;
        
        // Get the actual result content based on result type
        if(stmtResult.getType() == RESULT.STMT_RESULT_TYPE_SET){
            if(stmtResult.getRsSet() == null){
                LOG.error("Actual result set is null, cannot perform hint match");
                return false;
            }
            actualContent = stmtResult.getRsSet().toString();
        } else if(stmtResult.getType() == RESULT.STMT_RESULT_TYPE_ERROR){
            actualContent = stmtResult.getErrorMessage();
        } else if(stmtResult.getType() == RESULT.STMT_RESULT_TYPE_NONE){
            LOG.error("Actual result is NONE type, cannot perform hint match");
            return false;
        } else {
            actualContent = stmtResult.toString();
        }
        
        if(actualContent == null || actualContent.isEmpty()){
            LOG.error("Actual result content is null or empty, cannot perform hint match");
            return false;
        }
        
        // Check if all hint keywords are present in the actual result
        for(String keyword : hintKeywords){
            if(!actualContent.contains(keyword)){
                LOG.error(String.format("Hint keyword [%s] not found in actual result", keyword));
                return false;
            }
        }
        
        LOG.debug(String.format("All hint keywords %s found in actual result", hintKeywords));
        return true;
    }

    public int getType() {
        return type;
    }

    public void setType(int type) {
        this.type = type;
    }

    public String getErrorMessage() {
        return errorMessage;
    }

    public void setErrorMessage(String errorMessage) {
        this.errorMessage = errorMessage;
    }

    public RSSet getRsSet() {
        return rsSet;
    }

    public void setRsSet(RSSet rsSet) {
        if(rsSet == null){
            return;
        }
        
        this.rsSet = rsSet;
        if(this.command != null) {
            this.rsSet.setCommand(this.command);
            if (command.getSeparator().equals("both") || command.getSeparator().equals("space"))
                this.rsSet.setSeparator(RESULT.COLUMN_SEPARATOR_SPACE);
            else
                this.rsSet.setSeparator(RESULT.COLUMN_SEPARATOR_TABLE);

            //add sort key indexes
            for(int i = 0; i < command.getSortKeyIndexs().size();i++){
                this.rsSet.addSortKeyIndex(command.getSortKeyIndexs().get(i));
            }
        }
    }

    public String getOrginalRSText() {
        return orginalRSText;
    }

    public void setOrginalRSText(String orginalRSText) {
        this.orginalRSText = orginalRSText;
        //this.rsSet = ResultParser.convertToRSSet(orginalRSText,command.getSeparator());
    }

    public SqlCommand getCommand() {
        return command;
    }

    public void setCommand(SqlCommand command) {
        this.command = command;
        if(this.rsSet != null) {
            this.rsSet.setCommand(command);
            if (command.getSeparator().equals("both") || command.getSeparator().equals("space"))
                this.rsSet.setSeparator(RESULT.COLUMN_SEPARATOR_SPACE);
            else
                this.rsSet.setSeparator(RESULT.COLUMN_SEPARATOR_TABLE);

            //add sort key indexes
            for(int i = 0; i < command.getSortKeyIndexs().size();i++){
                this.rsSet.addSortKeyIndex(command.getSortKeyIndexs().get(i));
            }
        }
    }

    public String toString(){
        if(this.type == RESULT.STMT_RESULT_TYPE_SET){
            if(rsSet == null)
                return null;
            return rsSet.toString();
        }

        else if(this.type == RESULT.STMT_RESULT_TYPE_ERROR)
            return errorMessage;

        else if(this.type == RESULT.STMT_RESULT_TYPE_NONE)
            return null;

        else if(this.type == RESULT.STMT_RESULT_TYPE_ABNORMAL)
            return rsSet.getAbnormalError();
        else 
            return orginalRSText;
    }
    
    public static void main(String[] args){
        Pattern p = Pattern.compile("(Duplicate entry ')(.)(' for key 'int32')");
        //Pattern p = Pattern.compile("(Duplicate)([0-9]*$)");
        Matcher m = p.matcher("Duplicate entry '1' for key 'int32'");
        //Matcher m = p.matcher("Duplicate1");
        System.out.println("Duplicate entry '1fdasf1' for key 'int32'".matches("(Duplicate entry)([\\d\\D]*)(for key 'int32')"));
    }
}
